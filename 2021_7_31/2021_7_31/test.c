#define _CRT_SECURE_NO_WARNINGS 1
//理解整形提升
//#include<stdio.h>
//int main()
//{
//	char a = 3;   //一个字节，8个比特位
//	//0000 0000 0000 0000 0000 0000 0000 0011  -  3的补码(原码，反码，补码相同)
//	//0000 0011 - a里面真正存放的二进制序列(存放时会发生截断)
//
//	char b = 127;
//	//0000 0000 0000 0000 0000 0000 0111 1111  -  127的补码(原码，反码，补码相同)
//	//0111 1111 - b里面真正存放的二进制序列(存放时也会发生截断)
//
//	char c = a + b;
//	//a 与 b 在进行加法操作时，会先进行整形提升
//	//整形提升，高位补符号位
//	//a整形提升后的二进制序列：0000 0000 0000 0000 0000 0000 0000 0011
//	//b整形提升后的二进制序列：0000 0000 0000 0000 0000 0000 0111 1111
//	//然后进行相加：0000 0000 0000 0000 0000 0000 1000 0010
//	//最后发生截断，存放到c里面去：1000 0010
//
//	printf("%d\n", c);
//	//%d：以有符号十进制整数形式打印
//	//c先进行整形提升：1111 1111 1111 1111 1111 1111 1000 0010
//	//然后计算出它的原码：
//	// 1111 1111 1111 1111 1111 1111 1000 0010 - 补码
//	// 1111 1111 1111 1111 1111 1111 1000 0001 - 反码
//	// 1000 0000 0000 0000 0000 0000 0111 1110 - 原码
//	//最后打印出来的值就是 -126
//
//	return 0;
//}


//整形提升真实存在的例子
//#include<stdio.h>
//int main()
//{
//	char a = 0xb6;
//	// 0000 0000 0000 0000 0000 0000 1011 0110  -  0xb6
//	// 1011 0110  -  发生截断后，a里面存放的二进制序列
//
//	short b = 0xb600;
//	// 0000 0000 0000 0000 1011 0110 0000 0000  -  0xb600
//	// 1011 0110 0000 0000  -  发生截断后b里面存放的二进制序列
//
//	int c = 0xb6000000;
//	// 1011 0110 0000 0000 0000 0000 0000 0000  -  0xb6000000
//	// c里面存放的也是上面这个二进制序列
//
//	if (a == 0xb6)
//	// a先整形提升 - 1111 1111 1111 1111 1111 1111 1011 0110
//// 0xb6的二进制序列- 0000 0000 0000 0000 0000 0000 1011 0110
//		printf("a");   //为假，不打印
//	
//	if (b == 0xb600)
//	// b先整形提升 -   1111 1111 1111 1111 1011 0110 0000 0000
//// 0xb600的二进制序列- 0000 0000 0000 0000 1011 0110 0000 0000
//		printf("b");  //为假，不打印
//
//	if (c == 0xb6000000)
//    // c不用整形提升 -     1011 0110 0000 0000 0000 0000 0000 0000
//// 0xb6000000的二进制序列- 1011 0110 0000 0000 0000 0000 0000 0000
//		printf("c");  //为真，打印c
//
//	return 0;
//}

//例子二
//#include<stdio.h>
//int main()
//{
//	char c = 1;
//	printf("%u\n", sizeof(c)); //c为char - 1
//	printf("%u\n", sizeof(+c));//+c是一个表达式，所以要进行整形提升 - 4
//	printf("%u\n", sizeof(-c));//-c与+c一样。 - 4
//	return 0;
//}

//算术转换
//#include<stdio.h>
//int main()
//{
//	float a = 3.14f;
//	double b = 1.2;
//	int c = 0;
//	b = a + c;
//	printf("%lf\n", b);
//	return 0;
//}

//非法表达式 1
//#include<stdio.h>
//int main()
//{
//	int i = 10;
//	i = i-- - --i * (i = -3) * i++ + ++i;
//	printf("i = %d\n", i);
//	return 0;
//}

//非法表达式 2
//#include<stdio.h>
//int fun()
//{
//	static int count = 1;
//	return ++count;
//}
//int main()
//{
//	int answer;
//	answer = fun() - fun() * fun();
//	printf("%d\n", answer);     //输出多少？
//	return 0;
//}


//非法表达式 3
//#include<stdio.h>
//int main()
//{
//	int i = 1;
//	int ret = (++i) + (++i) + (++i);
//	printf("%d\n", ret);
//	printf("%d\n", i);
//	return 0;
//}


//指针的意义
//#include <stdio.h>
//int main()
//{
//	int a = 10;//在内存中开辟一块空间
//	char* p = &a;//这里我们对变量a，取出它的地址，可以使用&操作符。
//	//将a的地址存放在p变量中，p就是一个指针变量。
//	*p = 0;  //这里解引用修改的是一个字节的空间内容
//	int x = 1;
//	int* q = &x;
//	char* q1 = &x;
//	printf("%p\n", q);
//	printf("%p\n", q1);
//	printf("%p\n", q + 1);
//	printf("%p\n", q1 + 1);
//	return 0;
//}

//指针的类型决定了指针加减整数，所跳过的空间
//#include<stdio.h>
//
//int main()
//{
//	int arr[10] = { 0 };
//	int i = 0;
//
//	//四个字节四个字节来访问，进行修改
//	int* p = arr;
//	for (i = 0; i < 10; i++)
//	{
//		*(p + i) = 1;
//	}
//
//	//一个字节一个字节来访问，进行修改
//	char* pa = arr;
//	for (i = 0; i < 40; i++)
//	{
//		*(pa + i) = 1;
//	}
//	return 0;
//}


//野指针
//#include<stdio.h>
//int main()
//{
//	//int* p;  //指针没有初始化，就是一个野指针，它指向了一块未知的地址
//	////不初始化的指针变量的值是随机值
//	//*p = 10; //这里还对未知空间进行访问，错上加错。
//
//	//int arr[10] = { 0 };  //定义一个数组，有10个元素
//	//int i = 0; 
//	//int* p = arr;
//	//for (i = 0; i <= 10; i++)
//	////这里的p刚开始不是野指针，但它走着走着，访问到了第11个元素，而这个数组空间的大小只有10个元素
//	////所以这里由于指针越界访问，二成了一个野指针。
//	//{
//	//	*p = 1;
//	//	p++;
//	//}
//
//	return 0;
//}


//由于释放空间而产生的野指针
//#include<stdio.h>
//
//int* test()
//{
//	int a = 10;
//	return &a;  //这里返回的是a的地址，而变量a在函数执行完毕之后就会销毁，空间也就不在属于test函数
//}
//
//int main()
//{
//	int* p = test();
//	//这里还接收了a的地址，在下面进行访问打印出来，这里的p就是一个野指针，它访问了不属于它的空间
//	printf("hehe\n");
//
//	printf("%d\n", *p);
//
//	return 0;
//}

//避免野指针
//#include<stdio.h>
//
//int* test()
//{
//	int a = 1;
//	return &a;
//}
//
//int main()
//{
//	int a = 10;
//	int* p = &a;   //明确初始化，确定指向
//
//	int* b = NULL; //不知道指向时，置为NULL(空),在使用完之后，也要置为NULL
//
//	int arr[5] = { 0 };
//	int* p1 = arr;
//	*(p1 + 5) = 5;//避免指针越界访问
//
//	int* p2 = test();//使用函数时避免返回已经释放空间的地址
//
//	int* p3 = NULL;
//	*p3 = 1;     //对于空指针，是不能被访问的。(这只是一个标记，说明是一个指针，并且还没有使用)
//
//	//最重要的还是在使用指针时，需要细心的判断，从而避免野指针的出现。
//
//	return 0;
//}


//使用指针时，先进行有效的判断
#include <stdio.h>
int main()
{
	int* p = NULL;

	int a = 10;
	p = &a;
	if (p != NULL)  //判断是不是指向为NULL
	{
		*p = 20;
	}
	return 0;
}